1) Configurazioni: ok
2) Libro mastro: usiamo shared memory
3) Grado di concorrenza: usiamo il semaforo begin
4) Accesso al master: problema dei lettori/scrittori (due sem creati ed inizializzati dal master)
5) Transaction pool: coda di messaggi (niente rollback in caso di errore, mandi solo un messaggio per avvertire l'utente) oppure lista privata (funzioe associata all'uscita del nodo che stampa il numero di transazioni presenti e argv oppure coda di messaggi per passare la transazione transaction poolscartata al nuovo figlio).
La lista privata è probabilmente più veloce.
Usiamo la coda di messaggi, usando come sender e receiver i PID
6) Lista nodi disponibili: memori condivisa
7) Per simulazione elaborazione blocco: usiamo nanosleep
8) Meccanismo di uscita:
	-il master, alla rilevazione della condizione di uscita (**), invia un segnale a tutti i figli per
	provocarne la terminazione. Il padre si mette in wait e prosegue con le operazioni di stampa e pulizia
	solo dopo lo sblocco.
	
(**) le condizioni d'errore sono:
	-scadenza timer simulazione
	-libro mastro pieno (invio segnale dal nodo al master)
Le repository contiene 5 branches:
	-Master: caricheremo qui tutto ciò che riguarda il modulo master. Iniziate a fare i commit appena avete qualche funzionalità pronta.
	magari mettendo tutta in una "vostra" cartella [Nome_Master]
	-User, Node: come per master, ma per i moduli nodo ed utente
	-develop: metteremo qui le varie versioni del progetto ottenute unendo i moduli e tutti gli altri
	dati inerenti ad esso
	-master: caricheremo gradualmente le versioni più significative, fino ad arrivare a quella definitiva
	
	
Risorse IPC usate:
	-tre segmenti di shared memory per libro mastro
	-due segmenti di shared memory per la lista di utenti e nodi: 
		L'idea è allocare un segmento di memoria, allocato e caricato dal master, a cui gli utenti ed i noti sono collegati IN SOLA LETTURA.
		Il segmento contiene una linked list (la dimensione non è fissa e così la rimozione in caso di terminazione anticipata).
		La deallocazione della lista spetta al master, così come l'eliminazione di nodi corrispondenti ad utenti che terminano in anticipo.
		Dato che ci serve conoscere i PID dei nodi, conviene anche qui fare come per la lista dei PID utente.
		Anche qui l'allocazione, la deallocazione e la modifica (serve??) spettano al master, mentre nodi ed utenti sono collegati in sola lettura.
	-usiamo una coda di messaggi sola oppure uno per ogni nodo
	-un segmento di memoria per ogni processo con la lista degli amici (creato, inizializzato e deallocato dal master: l'utente vi si collega solo in lettura)

IL NODO NON DEVE DEALLOCARE IL BLOCCO, altrimenti lo si perde.
Il nodo deve allocare il blocco con malloc ed aggiungerlo alla blocklist
Mettere un handler che deallochi le cose in caso di terminazione con CTRL+C (in tal caso, mentre si è nell'handler un altro CTRL+C va deallocato) (lo faccio io come parte della terminazione del master)
