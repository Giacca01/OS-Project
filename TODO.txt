1) Inizializzare facilities
    -Allocazione var globali: Ok
    -aggancio a facilities: Ok
    -letture var d'ambiente: Ok
2) Leggere Variabili d'ambiente: Ok
3) Calcolo bilancio: Ok
4) Test e revisione
5) Controllare sincronizzazione register:
    -utente per calcolo bilancio: Ok
    -nodo per registrare blocco: Ok
    -master per stampa?? In teoria no, perchè accedi al registro
    quando tutti sono terminati (vedere bene se possono esserci figli non terminati)
5) COntrollare sincronizzazione lista utenti e nodi
    -utente per scelta utente destinatario: OK
    -utente per scelta nodo a cui chiedere processamento: OK
    -master per registrare terminazione nodi ed utenti
6) Sostituire sleep con nanosleep: utente e nodo ok
7) sostituire write con printf [VEDI AL FONDO DI QUESTO FILE]
8) Testare meccanismo deallocazioni IPC in caso di errore su master
9) Terminazione in caso di errore fork nel master
10) Segnalazione terminazione nodo ed utente a master:
    si invia un sigchld al master (attenzione a sganciare l'handler prima della wait a fine simulazione): 
        utente aggiornato, manca il resto
11) Aggiornare inizializzazione random in nodo (con clock_gettime ?): OK
12) Sostituire atoi/atol con strtoi/strtol: nodo e utente ok

4) Aggiornare file di intestazione: Ok
5) Sistemazione e Test Nodo:
    -implementare parte aggiuntiva versione FULL
        -controllo periodico transazioni su coda globale: Ok
    -aggiungere var d'ambiente SO_HOPS: Ok
    -togliere lettura file: si fa solo nel master; nei figli
    si leggono solo le var d'ambiente: Ok
    -il codice del nodo va sistemato in modo che sia rientrante
    perchè potrebbe essere interrotto dal segnale della scandenza
    del timer per inviare la transazione all'invio. OK
    Ci sarebbe anche la possibilità di non usare un segnale
    ed inviare una transazione ad ogni iterazione del ciclo di vita del nodo
    (così però non si fanno un po' troppi invii? E soprattutto, non si perde
    la possibilità di regolare la velocità??)
    No, lasciamo il timer
6) Collegarsi alla lista dei nodi in sola lettura: utente e nodo OK
7) Fissare con precisione il numero di partizioni (per me va bene vincolarlo a 3): sono per forza 3
8) Verificare stato utente e nodo in inivio transazione: OK
8.2) Verificare stato nodo amico quando gli mandi la transazioni: OK [viene fatto in funzione extractFriendNode]
9) Spostare TEST_ERROR_PARAM in info.h e correggerla (cosa bisogna cambiare ?)
10) Definire una procedura che deallochi le facilities in caso di errore: OK
    -modificare la procedura di deallocazione corrente in modo che sappia
    gestire senza errori il caso in cui un oggetto IPC non esiste: Ok (solo per nodo e utente(?))
    -agganciare la procedure con atexit in modo che venga sempre eseguita alla terminazione
    (o richiamarla in caso di errore: questa è la soluzione scelta, l'altra è inutile): OK
    -agganciarla anche in caso di terminazione anomala
11) COntrollare i collegamenti in sola lettura ai segmenti: nodo ok
12) COmpilare tutto (check parentesi calcolo bilancio)
13) Implementare parte full master: OK
14) Inserire, nel nodo, l'aggiunta dell'amico su richiesta del master: Ok
15) Aggiornare il progetto alla luce del fatto che i nodi possano terminare
17) Segnalazione fallimento transazione a sender: controllo in utente già fatto, invio da parte di nodo OK
18) Per il master e i segmenti di shared memory abbiamo usato la soluzione fair di Gunetti
19) Aggiungere sincronizzazione in calcolo bilancio: Ok
20) sistemare costante dimensione file
21) Rilevazione invio a nodi terminati: OK, in fase di invio viene scelto un nodo attivo
22) Eliminare facilities inutili da node (usersList, rdPartSem, mutexPartSem, noReadersPartition, noUserSegReaders, userListSem): OK
23) Aggiornare lettura da file con versione seguente
    /*
    Versione ottimizzata lettura da file
    int readConfigParameters()
{
    char *filename = "params.txt";
    FILE *fp = fopen(filename, "r");
    /* Reading line by line, max 128 bytes*/
    /*
        SPOSTATO IN INFO.h
    */
    /*const unsigned MAX_LENGTH = 128;*/
    /* Array that will contain the lines read from the file
    // each "row" of the "matrix" will contain a different file line*/
    char line[CONF_MAX_LINE_NO][CONF_MAX_LINE_SIZE];
    /* Counter of the number of lines in the file*/
    int k = 0;
    char *aus = NULL;
    int exitCode = 0;
    int i = 0;

    printf("Node: reading configuration parameters...\n");

    aus = (char *)calloc(35, sizeof(char));
    if (aus == NULL)
        unsafeErrorPrint("Node: failed to allocate memory. Error: ");
    else
    {
        /* Handles any error in opening the file*/
        if (fp == NULL)
        {
            sprintf(aus, "Error: could not open file %s", filename);
            unsafeErrorPrint(aus);
            exitCode = EXIT_FAILURE;
        }
        else
        {
            /* Inserts the lines read from the file into the array*/
            /* It also inserts the parameters read into environment variables*/
            /*
            CORREGGERE: segnalare errori fgets
        */
            while (fgets(line[k], CONF_MAX_LINE_SIZE, fp) != NULL)
            {
                putenv(line[i]);
                k++;
            }

            if (line[k] == NULL)
            {
                unsafeErrorPrint("Node: failed to read cofiguration parameters. Error: ");
                exitCode = EXIT_FAILURE;
            }
            else
            {
                /* Assigns the values ​​of the environment
        // variables to the global variables defined above*/
                assignEnvironmentVariables();
            }

            /* Close the file*/
            fclose(fp);
        }
    }

    return exitCode;
}
*/
24) Modificare nodo per fare in modo che solo i nodi normali attendano l'inizio della simulazione: OK
25) CONTROLLARE LO STATO DELL'UTENTE E DEL NODO A CUI SI INVIA UNA TRANSAZIONE: OK
    in utente ok (viene fatto in funzione di estrazione nodo e utente dest.), in nodo ok (viene fatto in funzione extractFriendNode)
26) Inviare notifica fallimento transazione a sender: controllo in utente già fatto, invio da parte di nodo OK
27) Verificare il bilancio prima di generare transazione in risposta a sigusr2: OK
28) Aggiungere lettura variabili globali nell'utente: OK
29) Sostituire write con printf (dove serve): utente ok, nodo ok, manca master
30) Handler CTRL + C master
31) Occorre rimuovere eventuali handler quando si esegue la procedura di terminazione??
32) DOBBIAMO STUDIARE SISTEMA DI AGGIONAMENTO STATO DEI NODI AMICI PER I NODI (AL MOMENTO NON POSSIAMO SAPERE SE UN NODO AMICO È TERMINATO O MENO!!!!)
    [abbiamo risolto stabilendo un massimo di nodi aggiuntivi che possono essere generati nella simulazione]: OK
33) Cosa facciamo in caso fallisca l'invio del messaggio che informa il sender che una sua transazione non è stata processata dal nodo?
34) Controllare i sizeof di tutte le msgsnd e msgrcv (non bisogna sottrarre la size del campo mType?): nodo OK
35) Sistemato ricezione amici da coda globale in nodo OK 
36) Verificare &sops[0]: funziona (OK)
37) CONTROLLARE SE LE OPERAZIONI SUL SET DI SEMAFORI VENGONO ESEGUITE NELL'ORDINE GIUSTO
38) In User dopo mandare sigchld al master, devo terminare? [DIPENDE DA COME IMPLEMENTIAMO HANDLER SIGCHLD]: OK (per ora termino)
39) Quando mandiamo in pause il nodo (in attesa che il padre gli dica di terminare), dovrei staccare anche l'handler dell'invio di 
    transazione ad amico ogni tot tempo? [FATTO]
40) Bisogna fare Handler SIGCHLD in master per gestire la terminazione prematura di nodi e utenti!!!
41) Controllare se funzione removeTransaction in User funziona correttamente

1) Parte full master: OK
2) SIstemare terminazione nodi (sincronizzazione accesso lista): IO
    -risolvere problema dimensione lista: Putroppo si risolve solo non redimensionando
    -controllare se si acceda alla lista nodi in modo sincronizzato
3) Aggiornare e testare il master integrando tutto: IO
4) Testare e uniformare il nodo
6) Testare e uniformare l'utente
7) Scrivere Relazione: Urru
9) Implementare modifiche scritte su file: Fontana
10) Cerchi problemi da risolvere: Fontana

Printf vs write:
    In tutte le funzioni che possono essere interrotti da un segnale per poi ripartire
    (gli handler, ma non solo) bisogna usare write

Tutto ciò entro il 12/01/2022

PUNTI ANCORA DA FARE:
5) -master per registrare terminazione nodi ed utenti
6) Sostituire sleep con nanosleep: utente e nodo ok
8) Testare meccanismo deallocazioni IPC in caso di errore su master
9) Terminazione in caso di errore fork nel master
10) Segnalazione terminazione nodo ed utente a master:
    si invia un sigchld al master (attenzione a sganciare l'handler prima della wait a fine simulazione): 
        utente aggiornato, manca il resto
9) Spostare TEST_ERROR_PARAM in info.h e correggerla (cosa bisogna cambiare ?)
11) COntrollare i collegamenti in sola lettura ai segmenti: nodo ok
12) COmpilare tutto (check parentesi calcolo bilancio)
15) Aggiornare il progetto alla luce del fatto che i nodi possano terminare
20) sistemare costante dimensione file
29) Sostituire write con printf (dove serve): utente ok, nodo ok, manca master
30) Handler CTRL + C master
31) Occorre rimuovere eventuali handler quando si esegue la procedura di terminazione??
33) Cosa facciamo in caso fallisca l'invio del messaggio che informa il sender che una sua transazione non è stata processata dal nodo?
37) CONTROLLARE SE LE OPERAZIONI SUL SET DI SEMAFORI VENGONO ESEGUITE NELL'ORDINE GIUSTO
39) Bisogna fare Handler SIGCHLD in master per gestire la terminazione prematura di nodi e utenti!!!
40) Controllare se funzione removeTransaction in User funziona correttamente

Conteggio nodi ed utenti attivi (copiato qui per emergenze, per ora non serve)
/*
                                    c_users_active = 0;
                                    c_nodes_active = 0;

                                    /* we enter the critical section for the noUserSegReadersPtr variabile */
                                    sops[0].sem_num = 0;
                                    sops[0].sem_op = -1;
                                    if (semop(userListSem, &sops[0], 1) == -1)
                                    {
                                        safeErrorPrint("Master: failed to reserve mutex usersList semaphore. Error: ");
                                    }
                                    else
                                    {
                                        (*noUserSegReadersPtr)++;
                                        if ((*noUserSegReadersPtr) == 1)
                                        {
                                            sops[0].sem_num = 2;
                                            sops[0].sem_op = -1; /* controllare se giusto!!! */
                                            if (semop(userListSem, &sops[0], 1) == -1)
                                            {
                                                safeErrorPrint("Master: failed to reserve write usersList semaphore. Error: ");
                                            }
                                            /* 
                                        * se lo scrittore sta scrivendo, allora il primo lettore che entrerà in questo 
                                        * ramo si addormenterà su questo semaforo.
                                        * se lo scrittore non sta scrivendo, allora il primo lettore decrementerà di 1 il
                                        * valore semaforico, in modo tale se lo scrittore vuole scrivere, si addormenterà 
                                        * sul semaforo
                                        */
                                        }
                                        /* we exit the critical section for the noUserSegReadersPtr variabile */
                                        sops[0].sem_num = 0;
                                        sops[0].sem_op = 1;
                                        if (semop(userListSem, &sops[0], 1) == -1)
                                        {
                                            safeErrorPrint("Master: failed to release mutex usersList semaphore. Error: ");
                                        }
                                        else
                                        {
                                            /* initializing budget for users processes */
                                            for (i = 0; i < SO_USERS_NUM; i++)
                                            {
                                                if (usersList[i].procState == ACTIVE)
                                                    c_users_active++;
                                            }

                                            /* we enter the critical section for the noUserSegReadersPtr variabile */
                                            sops[0].sem_num = 0;
                                            sops[0].sem_op = -1;
                                            if (semop(userListSem, &sops[0], 1) == -1)
                                            {
                                                safeErrorPrint("Master: failed to reserve mutex usersList semaphore. Error: ");
                                            }
                                            else
                                            {
                                                (*noUserSegReadersPtr)--;
                                                if ((*noUserSegReadersPtr) == 0)
                                                {
                                                    sops[0].sem_num = 2;
                                                    sops[0].sem_op = 1; /* controllare se giusto!!! */
                                                    if (semop(userListSem, &sops[0], 1) == -1)
                                                    {
                                                        safeErrorPrint("Master: failed to reserve write usersList semaphore. Error: ");
                                                    }
                                                    /* 
                                                * se sono l'ultimo lettore e smetto di leggere, allora devo riportare a 0
                                                * il valore semaforico in modo che se lo scrittore vuole scrivere possa farlo.
                                                */
                                                }
                                                /* we exit the critical section for the noUserSegReadersPtr variabile */
                                                sops[0].sem_num = 0;
                                                sops[0].sem_op = 1;
                                                if (semop(userListSem, &sops[0], 1) == -1)
                                                {
                                                    safeErrorPrint("Master: failed to release mutex usersList semaphore. Error: ");
                                                }
                                                else
                                                {
                                                    /* checking if there are active user processes, if not, simulation must terminate */
                                                    printf("Master: checking if there are active user processes...\n");
                                                    if (!c_users_active)
                                                    {
                                                        /* it contains an exit call
                                                    so no need to set exit code*/
                                                        printf("Master: no more active user processes. Terminating simulation...\n");
                                                        endOfSimulation(SIGUSR1);
                                                        /* CHECK IF ITS CORRECT ??? */
                                                    }
                                                    printf("Master: there are %d active user processes, continuing...\n", c_users_active);
                                                }
                                            }
                                        }
                                    }

                                    /* we enter the critical section for the noNodeSegReadersPtr variabile */
                                    sops[0].sem_num = 0;
                                    sops[0].sem_op = -1;
                                    if (semop(nodeListSem, &sops[0], 1) == -1)
                                    {
                                        safeErrorPrint("Master: failed to reserve mutex nodeList semaphore. Error: ");
                                    }
                                    else
                                    {
                                        (*noNodeSegReadersPtr)++;
                                        if ((*noNodeSegReadersPtr) == 1)
                                        {
                                            sops[0].sem_num = 2;
                                            sops[0].sem_op = -1; /* controllare se giusto!!! */
                                            if (semop(nodeListSem, &sops[0], 1) == -1)
                                            {
                                                safeErrorPrint("Master: failed to reserve write nodeList semaphore. Error: ");
                                            }
                                            /* 
                                            * se lo scrittore sta scrivendo, allora il primo lettore che entrerà in questo 
                                            * ramo si addormenterà su questo semaforo.
                                            * se lo scrittore non sta scrivendo, allora il primo lettore decrementerà di 1 il
                                            * valore semaforico, in modo tale se lo scrittore vuole scrivere, si addormenterà 
                                            * sul semaforo
                                            */
                                        }
                                        /* we exit the critical section for the noNodeSegReadersPtr variabile */
                                        sops[0].sem_num = 0;
                                        sops[0].sem_op = 1;
                                        if (semop(nodeListSem, &sops[0], 1) == -1)
                                        {
                                            safeErrorPrint("Master: failed to release mutex nodeList semaphore. Error: ");
                                        }
                                        else
                                        {
                                            /* initializing budget for nodes processes */
                                            for (i = 0; i < SO_NODES_NUM; i++)
                                            {
                                                if (nodesList[i].procState == ACTIVE)
                                                    c_nodes_active++;
                                            }

                                            /* we enter the critical section for the noNodeSegReadersPtr variabile */
                                            sops[0].sem_num = 0;
                                            sops[0].sem_op = -1;
                                            if (semop(nodeListSem, &sops[0], 1) == -1)
                                            {
                                                safeErrorPrint("Master: failed to reserve mutex nodeList semaphore. Error: ");
                                            }
                                            else
                                            {
                                                (*noNodeSegReadersPtr)--;
                                                if ((*noNodeSegReadersPtr) == 0)
                                                {
                                                    sops[0].sem_num = 2;
                                                    sops[0].sem_op = 1; /* controllare se giusto!!! */
                                                    if (semop(nodeListSem, &sops[0], 1) == -1)
                                                    {
                                                        safeErrorPrint("Master: failed to reserve write nodeList semaphore. Error: ");
                                                    }
                                                    /* 
                                                * se sono l'ultimo lettore e smetto di leggere, allora devo riportare a 0
                                                * il valore semaforico in modo che se lo scrittore vuole scrivere possa farlo.
                                                */
                                                }
                                                /* we exit the critical section for the noNodeSegReadersPtr variabile */
                                                sops[0].sem_num = 0;
                                                sops[0].sem_op = 1;
                                                if (semop(nodeListSem, &sops[0], 1) == -1)
                                                    safeErrorPrint("Master: failed to release mutex nodeList semaphore. Error: ");
                                                else
                                                    printf("Master: there are %d active node processes\n", c_nodes_active);
                                            }
                                        }
                                    }


/**** NEW NODE PROCESS CREATION ****/
                                    /***********************************/
                                    /* 
                                * creation of a new node process if a transaction doesn't fit in 
                                * any transaction pool of existing node processes
                                */
                                    c_msg_read = 0;
                                    transanctions_read = (Transaction *)calloc(SO_TP_SIZE, sizeof(Transaction)); /* array of transactions read from global queue */

                                    /* messages reading cycle */
                                    while (msgrcv(globalQueueId, &msg_from_node, sizeof(msg_from_node) - sizeof(long), (long)getpid(), IPC_NOWAIT | MSG_COPY) != -1 && c_msg_read < SO_TP_SIZE)
                                    {
                                        /* come dimensione specifichiamo sizeof(msg_from_node)-sizeof(long) perché bisogna specificare la dimensione del testo, non dell'intera struttura */
                                        /* come mType prendiamo i messaggi destinati al Master, cioè il suo pid (prende il primo messaggio con quel mType) */

                                        /* in questo caso cerchiamo i messaggi con msgContent NEWNODE */
                                        if (msg_from_node.msgContent == NEWNODE)
                                        {
                                            /* 
                                        * per aggiungere la transazione alla transaction pool, devo aggiungere un nuovo messaggio 
                                        * alla msgqueue che sarebbe la tp del nuovo nodo 
                                        * siccome prima di creare la TP del nuovo nodo devo accertarmi che ci sia un nuovo nodo da creare,
                                        * creiamo una lista di TPElement di massimo SO_TP_SIZE transazioni e poi quando abbiamo creato la TP
                                        * del nuovo nodo ci inseriamo i messaggi sopra. 
                                        */
                                            /*
                                                Al nuovo nodo viene passata una sola transazione, quella che
                                                non ha trovato alcun collocamento
                                            */
                                            memcpy(&transanctions_read[c_msg_read], &msg_from_node.transaction, sizeof(msg_from_node.transaction));
                                            /* DA TESTARE !!!!!! */

                                            c_msg_read++;
                                        }
                                        else
                                        {
                                            /* Reinserting the message that we have consumed from the global queue */
                                            if (msgsnd(globalQueueId, &msg_from_node, sizeof(msg_from_node) - sizeof(long), 0) == -1)
                                            {
                                                unsafeErrorPrint("Master: failed to reinsert the message read from the global queue while checking for new node creation. Error: ");
                                                exit(EXIT_FAILURE); /* VA SOSTITUITA CON EndOfSimulation ??? */
                                                /* This is necessary, otherwise the message won't be reinserted in queue and transaction lost forever */
                                            }
                                        }
                                    }

                                    /* SHOULD CHECK IF ERRNO is ENOMSG, otherwise an error occurred */
                                    if (errno == ENOMSG)
                                    {
                                        if (c_msg_read == 0)
                                        {
                                            printf("Master: creation of new node not needed\n");
                                        }
                                        else
                                        {
                                            printf("Master: no more transactions to read from global queue. Starting creation of new node...\n");

                                            /******* CREATION OF NEW NODE PROCESS *******/
                                            /********************************************/

                                            id_new_friends = (int *)calloc(SO_FRIENDS_NUM, sizeof(int)); /* array to keep track of already chosen new friends */

                                            /* setting every entry of array to -1 (it rappresents "not chosen") */
                                            for (i = 0; i < SO_FRIENDS_NUM; i++)
                                                id_new_friends[i] = -1;

                                            switch (fork())
                                            {
                                            case -1:
                                                /* Handle error */
                                                unsafeErrorPrint("Master: failed to fork the new node process. Error: ");
                                                exit(EXIT_FAILURE); /* VA SOSTITUITO CON EndOfSimulation ??? */
                                                /* Is this necessary ??? */
                                            case 0:
                                                /* NEW NODE */

                                                /* Adding new node to budgetlist */
                                                new_el = malloc(sizeof(*new_el));
                                                new_el->proc_pid = getpid();
                                                new_el->budget = 0;
                                                new_el->p_type = 1;
                                                insert_ordered(new_el);

                                                /* Updating number of effective active processes */
                                                noEffective++;

                                                srand(getpid()); /* we put it here so that for every new node we generate a different sequence */

                                                /* Creation of list of friends for new node */
                                                for (i = 0; i < SO_FRIENDS_NUM; i++)
                                                {
                                                    if (i == 0)
                                                    {
                                                        /* first friend in array, no need to check if already chosen */
                                                        index = rand() % SO_NODES_NUM; /* generate new index */
                                                    }
                                                    else
                                                    {
                                                        new = 0;
                                                        /* choosing a new friend */
                                                        while (!new)
                                                        {
                                                            index = rand() % SO_NODES_NUM; /* generate new index */
                                                            /* check if it is already a friend */
                                                            j = 0;
                                                            while (j < SO_FRIENDS_NUM && !new)
                                                            {
                                                                if (id_new_friends[j] == -1)
                                                                    new = 1; /* no friend in this position */
                                                                else if (id_new_friends[j] == index)
                                                                    break; /* if friend already chosen, change index */
                                                                j++;
                                                            }
                                                        }
                                                    }

                                                    /* adding new index friend to array */
                                                    id_new_friends[i] = index;

                                                    /* send a message on global queue to new node informing it of its new friend */

                                                    /* we enter the critical section for the noNodeSegReadersPtr variabile */
                                                    sops[0].sem_num = 0;
                                                    sops[0].sem_op = -1;
                                                    if (semop(nodeListSem, &sops[0], 1) == -1)
                                                    {
                                                        safeErrorPrint("Master: failed to reserve mutex nodeList semaphore. Error: ");
                                                    }
                                                    else
                                                    {
                                                        (*noNodeSegReadersPtr)++;
                                                        if ((*noNodeSegReadersPtr) == 1)
                                                        {
                                                            sops[0].sem_num = 2;
                                                            sops[0].sem_op = -1; /* controllare se giusto!!! */
                                                            if (semop(nodeListSem, &sops[0], 1) == -1)
                                                            {
                                                                safeErrorPrint("Master: failed to reserve write nodeList semaphore. Error: ");
                                                            }
                                                            /* 
                                                            * se lo scrittore sta scrivendo, allora il primo lettore che entrerà in questo 
                                                            * ramo si addormenterà su questo semaforo.
                                                            * se lo scrittore non sta scrivendo, allora il primo lettore decrementerà di 1 il
                                                            * valore semaforico, in modo tale se lo scrittore vuole scrivere, si addormenterà 
                                                            * sul semaforo
                                                            */
                                                        }
                                                        /* we exit the critical section for the noNodeSegReadersPtr variabile */
                                                        sops[0].sem_num = 0;
                                                        sops[0].sem_op = 1;
                                                        if (semop(nodeListSem, &sops[0], 1) == -1)
                                                        {
                                                            safeErrorPrint("Master: failed to release mutex nodeList semaphore. Error: ");
                                                        }
                                                        else
                                                        {
                                                            /* declaration of node to send to new friend */
                                                            msg_to_node.mType = getpid();
                                                            msg_to_node.msgContent = FRIENDINIT;
                                                            msg_to_node.friend.procId = nodesList[index].procId;
                                                            msg_to_node.friend.procState = ACTIVE;

                                                            /* we enter the critical section for the noNodeSegReadersPtr variabile */
                                                            sops[0].sem_num = 0;
                                                            sops[0].sem_op = -1;
                                                            if (semop(nodeListSem, &sops[0], 1) == -1)
                                                            {
                                                                safeErrorPrint("Master: failed to reserve mutex nodeList semaphore. Error: ");
                                                            }
                                                            else
                                                            {
                                                                (*noNodeSegReadersPtr)--;
                                                                if ((*noNodeSegReadersPtr) == 0)
                                                                {
                                                                    sops[0].sem_num = 2;
                                                                    sops[0].sem_op = 1; /* controllare se giusto!!! */
                                                                    if (semop(nodeListSem, &sops[0], 1) == -1)
                                                                    {
                                                                        safeErrorPrint("Master: failed to reserve write nodeList semaphore. Error: ");
                                                                    }
                                                                    /* 
                                                                    * se sono l'ultimo lettore e smetto di leggere, allora devo riportare a 0
                                                                    * il valore semaforico in modo che se lo scrittore vuole scrivere possa farlo.
                                                                    */
                                                                }
                                                                /* we exit the critical section for the noNodeSegReadersPtr variabile */
                                                                sops[0].sem_num = 0;
                                                                sops[0].sem_op = 1;
                                                                if (semop(nodeListSem, &sops[0], 1) == -1)
                                                                {
                                                                    safeErrorPrint("Master: failed to release mutex nodeList semaphore. Error: ");
                                                                }
                                                                else if (msgsnd(globalQueueId, &msg_to_node, sizeof(msg_to_node) - sizeof(long), 0) == -1)
                                                                {
                                                                    unsafeErrorPrint("Master: failed to send a friend node to the new node process. Error: ");
                                                                    exit(EXIT_FAILURE); /* VA SOSTITUITO CON EndOfSimulation ??? */
                                                                    /* This is necessary, otherwise the node won't be notified of its friend */
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                /* resetting every entry of array to -1 (it rappresents "not chosen") */
                                                for (i = 0; i < SO_FRIENDS_NUM; i++)
                                                    id_new_friends[i] = -1;

                                                /* Selection of random nodes which need to add the new node as a friend */
                                                for (i = 0; i < SO_FRIENDS_NUM; i++)
                                                {
                                                    if (i == 0)
                                                    {
                                                        /* first node in array, no need to check if already chosen */
                                                        index = rand() % SO_NODES_NUM; /* generate new index */
                                                    }
                                                    else
                                                    {
                                                        new = 0;
                                                        /* choosing a new node */
                                                        while (!new)
                                                        {
                                                            index = rand() % SO_NODES_NUM; /* generate new index */
                                                            /* check if it has already been chosen */
                                                            j = 0;
                                                            while (j < SO_FRIENDS_NUM && !new)
                                                            {
                                                                if (id_new_friends[j] == -1)
                                                                    new = 1; /* no node in this position */
                                                                else if (id_new_friends[j] == index)
                                                                    break; /* if node already chosen, change index */
                                                                j++;
                                                            }
                                                        }
                                                    }

                                                    /* adding new index node to array */
                                                    id_new_friends[i] = index;

                                                    /* we enter the critical section for the noNodeSegReadersPtr variabile */
                                                    sops[0].sem_num = 0;
                                                    sops[0].sem_op = -1;
                                                    if (semop(nodeListSem, &sops[0], 1) == -1)
                                                    {
                                                        safeErrorPrint("Master: failed to reserve mutex nodeList semaphore. Error: ");
                                                    }
                                                    else
                                                    {
                                                        (*noNodeSegReadersPtr)++;
                                                        if ((*noNodeSegReadersPtr) == 1)
                                                        {
                                                            sops[0].sem_num = 2;
                                                            sops[0].sem_op = -1; /* controllare se giusto!!! */
                                                            if (semop(nodeListSem, &sops[0], 1) == -1)
                                                            {
                                                                safeErrorPrint("Master: failed to reserve write nodeList semaphore. Error: ");
                                                            }
                                                            /* 
                                                            * se lo scrittore sta scrivendo, allora il primo lettore che entrerà in questo 
                                                            * ramo si addormenterà su questo semaforo.
                                                            * se lo scrittore non sta scrivendo, allora il primo lettore decrementerà di 1 il
                                                            * valore semaforico, in modo tale se lo scrittore vuole scrivere, si addormenterà 
                                                            * sul semaforo
                                                            */
                                                        }
                                                        /* we exit the critical section for the noNodeSegReadersPtr variabile */
                                                        sops[0].sem_num = 0;
                                                        sops[0].sem_op = 1;
                                                        if (semop(nodeListSem, &sops[0], 1) == -1)
                                                        {
                                                            safeErrorPrint("Master: failed to release mutex nodeList semaphore. Error: ");
                                                        }
                                                        else
                                                        {
                                                            /* here we notice the friend node of its new friend (the new node created here) */
                                                            msg_to_node.mType = nodesList[index].procId; /* devo accedervi in mutua esclusione (vedi foto Fede) */
                                                            msg_to_node.msgContent = NEWFRIEND;
                                                            msg_to_node.friend.procId = getpid();
                                                            msg_to_node.friend.procState = ACTIVE;

                                                            /* we enter the critical section for the noNodeSegReadersPtr variabile */
                                                            sops[0].sem_num = 0;
                                                            sops[0].sem_op = -1;
                                                            if (semop(nodeListSem, &sops[0], 1) == -1)
                                                            {
                                                                safeErrorPrint("Master: failed to reserve mutex nodeList semaphore. Error: ");
                                                            }
                                                            else
                                                            {
                                                                (*noNodeSegReadersPtr)--;
                                                                if ((*noNodeSegReadersPtr) == 0)
                                                                {
                                                                    sops[0].sem_num = 2;
                                                                    sops[0].sem_op = 1; /* controllare se giusto!!! */
                                                                    if (semop(nodeListSem, &sops[0], 1) == -1)
                                                                    {
                                                                        safeErrorPrint("Master: failed to reserve write nodeList semaphore. Error: ");
                                                                    }
                                                                    /* 
                                                                    * se sono l'ultimo lettore e smetto di leggere, allora devo riportare a 0
                                                                    * il valore semaforico in modo che se lo scrittore vuole scrivere possa farlo.
                                                                    */
                                                                }
                                                                /* we exit the critical section for the noNodeSegReadersPtr variabile */
                                                                sops[0].sem_num = 0;
                                                                sops[0].sem_op = 1;
                                                                if (semop(nodeListSem, &sops[0], 1) == -1)
                                                                {
                                                                    safeErrorPrint("Master: failed to release mutex nodeList semaphore. Error: ");
                                                                }
                                                                else if (msgsnd(globalQueueId, &msg_to_node, sizeof(msg_to_node) - sizeof(long), 0) == -1)
                                                                {
                                                                    unsafeErrorPrint("Master: failed to send a message to inform a node of its new friend. Error: ");
                                                                    exit(EXIT_FAILURE); /* VA SOSTITUITO CON EndOfSimulation ??? */
                                                                    /* This is necessary, otherwise the node won't be notified of its new friend (?) */
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                /* CAPIRE SE DA ULTIME DISPOSIZIONI SI DEVE ANCORA FARE O NO */

                                                /* add a new entry to the tpList array */
                                                tplLength++;
                                                tpList = (TPElement *)realloc(tpList, sizeof(TPElement) * tplLength);
                                                /* Initialize messages queue for transactions pools */
                                                tpList[tplLength - 1].procId = getpid();
                                                tpList[tplLength - 1].msgQId = msgget(ftok(MSGFILEPATH, getpid()), IPC_CREAT | IPC_EXCL | 0600);

                                                if (tpList[tplLength - 1].msgQId == -1)
                                                {
                                                    unsafeErrorPrint("Master: failed to create the message queue for the transaction pool of the new node process. Error: ");
                                                    exit(EXIT_FAILURE); /* VA SOSTITUITO CON EndOfSimulation ??? */
                                                }

                                                tp_new_node = tpList[tplLength - 1].msgQId;
                                                /* here we have to insert transactions read from global queue in new node TP*/
                                                for (tr_written = 0; tr_written < c_msg_read; tr_written++)
                                                { /* c_msg_read is the number of transactions actually read */
                                                    new_trans.mType = getpid();
                                                    memcpy(&new_trans.transaction, &transanctions_read[tr_written], sizeof(new_trans.transaction));
                                                    if (msgsnd(tp_new_node, &new_trans, sizeof(new_trans) - sizeof(long), 0) == -1)
                                                    {
                                                        unsafeErrorPrint("Master: failed to send a transaction to the new node process. Error: ");
                                                        exit(EXIT_FAILURE); /* VA SOSTITUITO CON EndOfSimulation ??? */
                                                        /* This is necessary, otherwise a transaction could be lost forever */
                                                    }
                                                }

                                                /* TO COMPLETE....... */
                                                /*execve(...);*/

                                                exit(EXIT_SUCCESS); /* da rimuovere con execve */
                                                break;
                                            default:
                                                /* MASTER */
                                                break;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        unsafeErrorPrint("Master: failed to retrieve new node messages from global queue. Error: ");
                                        /* 
                                    * DEVO FARE EXIT????? 
                                    * Dipende, perché se è un errore momentaneo che al prossimo ciclo non riaccade, allora non 
                                    * è necessario fare la exit, ma se si verifica un errore a tutti i cicli non è possibile 
                                    * leggere messaggi dalla coda, quindi si finisce con il non creare un nuovo nodo, non processare
                                    * alcune transazioni e si può riempire la coda globale, rischiando di mandare in wait tutti i 
                                    * restanti processi nodi e utenti. Quindi sarebbe opportuno fare exit appena si verifica un errore
                                    * oppure utilizzare un contatore (occorre stabilire una soglia di ripetizione dell'errore). Per 
                                    * ora lo lasciamo.
                                    */
                                        exit(EXIT_FAILURE); /* VA SOSTITUITO CON EndOfSimulation ??? */
                                    }

                                    /**** END OF NEW NODE PROCESS CREATION ****/
                                    /******************************************/