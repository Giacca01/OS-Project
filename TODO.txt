1) Inizializzare facilities
    -Allocazione var globali: Ok
    -aggancio a facilities: Ok
    -letture var d'ambiente: Ok
2) Leggere Variabili d'ambiente: Ok
3) Calcolo bilancio: Ok
4) Test e revisione
5) Controllare sincronizzazione register:
    -utente per calcolo bilancio: Ok
    -nodo per registrare blocco: Ok
    -master per stampa?? In teoria no, perchè accedi al registro
    quando tutti sono terminati (vedere bene se possono esserci figli non terminati)
5) COntrollare sincronizzazione lista utenti e nodi
    -utente per scelta utente destinatario: OK
    -utente per scelta nodo a cui chiedere processamento: OK
    -master per registare terminazione nodi ed utenti
6) Sostituire sleep con nanosleep
7) sostituire write con dprintf (prima controllare se dprintf è reentrant come write)
8) Testare meccanismo deallocazioni IPC in caso di errore su master
9) Terminazione in caso di errore fork nel master
10) Segnalazione terminazione nodo ed utente a master:
    si invia un sigchld al master (attenzione a sganciare l'handler prima della wait a fine simulazione): utente aggiornato, manca il resto
11) Aggiornare inizializzazione random in nodo (con clock_gettime ?)
12) Sostituire atoi/atol con strtoi/strtol

4) Aggiornare file di intestazione: Ok
5) Sistemazione e Test Nodo:
    -implementare parte aggiuntiva versione FULL
        -controllo periodico transazioni su coda globale: Ok
    -aggiungere var d'ambiente SO_HOPS: Ok
    -togliere lettura file: si fa solo nel master; nei figli
    si leggono solo le var d'ambiente: Ok
    -il codice del nodo va sistemato in modo che sia rientrante
    perchè potrebbe essere interrotto dal segnale della scandenza
    del timer per inviare la transazione all'invio.
    Ci sarebbe anche la possibilità di non usare un segnale
    ed inviare una transazione ad ogni iterazione del ciclo di vita del nodo
    (così però non si fanno un po' troppi invii? E soprattutto, non si perde
    la possibilità di regolare la velocità??)
    No, lasciamo il timer
6) Collegarsi alla lista dei nodi in sola lettura:OK
7) Fissare con precisione il numero di partizioni (per me va bene vincolarlo a 3): sono per forza 3
8) Verificare stato utente e nodo in inivio transazione: OK
8.2) Verificare stato nodo amico quando gli mandi la transazioni
9) Spostare TEST_ERROR_PARAM in info.h e correggerla
10) Definire una procedura che deallochi le facilities in caso di errore: OK
    -modificare la procedura di deallocazione corrente in modo che sappia
    gestire senza errori il caso in cui un ogetto IPC non esiste: Ok (solo per nodo)
    -agganciare la procedure con atexit in modo che venga sempre eseguita alla terminazione
    (o richiamarla in caso di errore: questa è la soluzione scelta, l'altra è inutile): OK
    -agganciarla anche in caso di terminazione anomala
11) COntrollare i collegamenti in sola lettura ai segmenti
12) COmpilare tutto (check parentesi calcolo bilancio)
13) Implementare parte full master
14) Inserire, nel nodo, l'aggiunta dell'amico su richiesta del master: Ok
15) Aggiornare il progetto alla luce del fatto che i nodi possano terminare
17) Segnalazione fallimento transazione a sender
18) Per il master e i segmenti di shared memory abbiamo usato la soluzione fair di Gunetti
19) Aggiungere sincronizzazione in calcolo bilancio: Ok
20) sistemare costante dimensione file
21) Rilevazione invio a nodi terminati
22) Eliminare facilities inutili da node
23) Aggiornare lettura da file con versione seguente
    /*
    Versione ottimizzata lettura da file
    int readConfigParameters()
{
    char *filename = "params.txt";
    FILE *fp = fopen(filename, "r");
    /* Reading line by line, max 128 bytes*/
    /*
        SPOSTATO IN INFO.h
    */
    /*const unsigned MAX_LENGTH = 128;*/
    /* Array that will contain the lines read from the file
    // each "row" of the "matrix" will contain a different file line*/
    char line[CONF_MAX_LINE_NO][CONF_MAX_LINE_SIZE];
    /* Counter of the number of lines in the file*/
    int k = 0;
    char *aus = NULL;
    int exitCode = 0;
    int i = 0;

    printf("Node: reading configuration parameters...\n");

    aus = (char *)calloc(35, sizeof(char));
    if (aus == NULL)
        unsafeErrorPrint("Node: failed to allocate memory. Error: ");
    else
    {
        /* Handles any error in opening the file*/
        if (fp == NULL)
        {
            sprintf(aus, "Error: could not open file %s", filename);
            unsafeErrorPrint(aus);
            exitCode = EXIT_FAILURE;
        }
        else
        {
            /* Inserts the lines read from the file into the array*/
            /* It also inserts the parameters read into environment variables*/
            /*
            CORREGGERE: segnalare errori fgets
        */
            while (fgets(line[k], CONF_MAX_LINE_SIZE, fp) != NULL)
            {
                putenv(line[i]);
                k++;
            }

            if (line[k] == NULL)
            {
                unsafeErrorPrint("Node: failed to read cofiguration parameters. Error: ");
                exitCode = EXIT_FAILURE;
            }
            else
            {
                /* Assigns the values ​​of the environment
        // variables to the global variables defined above*/
                assignEnvironmentVariables();
            }

            /* Close the file*/
            fclose(fp);
        }
    }

    return exitCode;
}
*/

1) Parte full master: IO
2) SIstemare terminazione nodi: IO
3) Aggiornare e testare il master integrando tutto: IO
4) Testare e uniformare il nodo
6) Testare e uniformare l'utente
7) Scrivere Relazione: Urru
9) Implementare modifiche scritte su file: Fontana
10) Cerchi problemi da risolvere: Fontana

Tutto ciò entro il 12/01/2022