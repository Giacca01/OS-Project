1) Creare un file .h per ogni processo e metterci le macro per segnalare gli errori
(Oppure modificare le macro in modo che accettino il tipo di modulo)

boolean readConfigParameters()
{
    char *filename = "params.txt";
    FILE *fp = fopen(filename, "r");
    /* Reading line by line, max 128 bytes*/
    /* 
        Array that will contain the lines read from the file:
        each "row" of the "matrix" will contain a different file line
    */
    char line[CONF_MAX_LINE_NO][CONF_MAX_LINE_SIZE];
    /* Counter of the number of lines in the file*/
    int k = 0;
    char *aus = NULL;
    int i = 0;
    boolean ret = TRUE;

    printf("Master: reading configuration parameters...\n");

    aus = (char *)calloc(35, sizeof(char));
    if (aus == NULL)
        unsafeErrorPrint("Master: failed to allocate memory. Error: ");
    else
    {
        /* Handles any error in opening the file*/
        if (fp == NULL)
        {
            sprintf(aus, "Master: could not open file %s", filename);
            unsafeErrorPrint(aus);
            ret = FALSE;
        }
        else
        {
            /* Inserts the lines read from the file into the array*/
            /* It also inserts the parameters read into environment variables*/
            while (fgets(line[k], CONF_MAX_LINE_SIZE, fp) != NULL)
            {
                putenv(line[k]);
                k++;
            }

            if (line[k] == NULL && errno)
            {
                unsafeErrorPrint("Master: failed to read cofiguration parameters. Error: ");
                ret = FALSE;
            }
            else {
                ret = assignEnvironmentVariables();
            }

            /* Close the file*/
            fclose(fp);
        }
    }

    return ret;
}

2) Persistenza associazione segnali
3) alrm vs settimer
4) Handler per graceful termintation con SIGNT E SIGTERM
5) SIstemare puntatori in modo da evitare segmentation fault: ok
6) Capire perchè il balance degli users sia negativo: Ok
7) PERSISTENZA HANDLER
8) Regolare dimensione coda globale in base a numero nodi ed utenti:
    -nella seconda simulazione è troppo alta, quindi va settata al : oK
    -nella terza simulazione per ora è troppo piccola
    -sistemare dimensione tp: Ok
    -vedere perchè l'hadler del ctrl + c non funzioni
    Il problema è che la singola tp in alcune configurazioni è troppo piccola 
    e non contiene abbastanza transazioni da poter creare un blocco della dimensione richiesta
    mentre nelle configurazioni con tanti processi la coda globale è troppo piccola
9) Risolvere bug seconda configurazione 
10) Refactoring
11) Regolare dimensione tp: Ok 
12) controllare che i nodi bastardi chiedano di creare un amico: Ok
13) Completare stampa in caso di terminazione: ok (?)
14) Controllare il comportamento dei nodi creati dal master su richiesta di un altro nodo
15) Risolvere segmentation fault nodi
16) Risolvere problema abort
17) Testare configurazione 2
18) Capire perchè l'utente si blocchi poco prima di terminare: perchè la coda globale è piena
19) Capire perchè ci sia la double free: Ok ??
20) Capire perchè il ctrl + c non funzioni con tanti processi
21) Sistemare stampa transazioni rimanenti
22) Capire perchè i nuovi nodi non facciano nulla: ok
23) Rimettere controllo coda globale e testare cosa viene fuori
24) Test: Ok
25) Togliere write nodo e user
26) Testare segnale generazione transazione: Ok
27) SIstemare makefile
28) Vedere se rimane una coda da eliminare: sì, nei casi di terminazione anticipata PER COLPA DI UN ERRORE sembra rimanere una coda

1) Registro pieno: Ok
2) vedere se malloc unsorted sia colpa della dimensione delle tp: Ok, no
3) sistemare nodo ed utente 
4) sistemare il makefile
5) sisteamare terminazione in caso di segmentation fault
6) RImuovere i tre segmenti da  byte che non vengono cancellati
7) Modificare in modo che il pathname del file di configurazione venga passato come parametro