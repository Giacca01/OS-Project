4) Aggiornare file di intestazione: Ok
5) Sistemazione e Test Nodo:
    -implementare parte aggiuntiva versione FULL
        -controllo periodico transazioni su coda globale: Ok
    -aggiungere var d'ambiente SO_HOPS: Ok
    -togliere lettura file: si fa solo nel master; nei figli
    si leggono solo le var d'ambiente: Ok
    -il codice del nodo va sistemato in modo che sia rientrante
    perchè potrebbe essere interrotto dal segnale della scandenza
    del timer per inviare la transazione all'invio.
    Ci sarebbe anche la possibilità di non usare un segnale
    ed inviare una transazione ad ogni iterazione del ciclo di vita del nodo
    (così però non si fanno un po' troppi invii? E soprattutto, non si perde
    la possibilità di regolare la velocità??)
6) Collegarsi alla lista dei nodi in sola lettura:OK
7) Fissare con precisione il numero di partizioni (per me va bene vincolarlo a 3)
8) /*
        Se un nodo è terminato ed un processo prova a mandargli una transazione bisogna
        segnalare un errore
       */
9) Spostare TEST_ERROR_PARAM in info.h e correggerla
10) Definire una procedura che deallochi le facilities in caso di errore: OK
    -modificare la procedura di deallocazione corrente in modo che sappia
    gestire senza errori il caso in cui un ogetto IPC non esiste: Ok (solo per nodo)
    -agganciare la procedure con atexit in modo che venga sempre eseguita alla terminazione
    (o richiamarla in caso di errore: questa è la soluzione scelta, l'altra è inutile): OK
    -agganciarla anche in caso di terminazione anomala
11) COntrollare i collegamenti in sola lettura ai segmenti
12) COmpilare tutto (check parentesi calcolo bilancio)
13) Implementare parte full master
14) Inserire, nel nodo, l'aggiunta dell'amico su richiesta del master: Ok
15) Aggiornare il progetto alla luce del fatto che i nodi possano terminare
16) Rilevare inivio ad utenti terminati
    -bisogna farlo sia nel nodo che nell'utente???
17) Segnalazione fallimento transazione a sender
18) Per il master e i segmenti di shared memory abbiamo usato una soluzione read first, va bene?
19) Aggiungere sincronizzazione in calcolo bilancio
20) sistemare costante dimensione file
21) Rilevazione invio a nodi terminati
22) Eliminare facilities inutili da node
23) Controllare valori semafori
/*
    Versione ottimizzata lettura da file
    int readConfigParameters()
{
    char *filename = "params.txt";
    FILE *fp = fopen(filename, "r");
    /* Reading line by line, max 128 bytes*/
    /*
        SPOSTATO IN INFO.h
    */
    /*const unsigned MAX_LENGTH = 128;*/
    /* Array that will contain the lines read from the file
    // each "row" of the "matrix" will contain a different file line*/
    char line[CONF_MAX_LINE_NO][CONF_MAX_LINE_SIZE];
    /* Counter of the number of lines in the file*/
    int k = 0;
    char *aus = NULL;
    int exitCode = 0;
    int i = 0;

    printf("Node: reading configuration parameters...\n");

    aus = (char *)calloc(35, sizeof(char));
    if (aus == NULL)
        unsafeErrorPrint("Node: failed to allocate memory. Error: ");
    else
    {
        /* Handles any error in opening the file*/
        if (fp == NULL)
        {
            sprintf(aus, "Error: could not open file %s", filename);
            unsafeErrorPrint(aus);
            exitCode = EXIT_FAILURE;
        }
        else
        {
            /* Inserts the lines read from the file into the array*/
            /* It also inserts the parameters read into environment variables*/
            /*
            CORREGGERE: segnalare errori fgets
        */
            while (fgets(line[k], CONF_MAX_LINE_SIZE, fp) != NULL)
            {
                putenv(line[i]);
                k++;
            }

            if (line[k] == NULL)
            {
                unsafeErrorPrint("Node: failed to read cofiguration parameters. Error: ");
                exitCode = EXIT_FAILURE;
            }
            else
            {
                /* Assigns the values ​​of the environment
        // variables to the global variables defined above*/
                assignEnvironmentVariables();
            }

            /* Close the file*/
            fclose(fp);
        }
    }

    return exitCode;
}
*/