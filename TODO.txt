1) Inizializzare facilities
    -Allocazione var globali: Ok
    -aggancio a facilities: Ok
    -letture var d'ambiente: Ok
2) Leggere Variabili d'ambiente: Ok
3) Calcolo bilancio: Ok
4) Test e revisione
5) Controllare sincronizzazione register:
    -utente per calcolo bilancio: Ok
    -nodo per registrare blocco: Ok
    -master per stampa?? In teoria no, perchè accedi al registro
    quando tutti sono terminati (vedere bene se possono esserci figli non terminati)
5) COntrollare sincronizzazione lista utenti e nodi
    -utente per scelta utente destinatario: OK
    -utente per scelta nodo a cui chiedere processamento: OK
    -master per registrare terminazione nodi ed utenti
6) Sostituire sleep con nanosleep: utente e nodo ok
7) sostituire write con printf [VEDI AL FONDO DI QUESTO FILE]
8) Testare meccanismo deallocazioni IPC in caso di errore su master
9) Terminazione in caso di errore fork nel master
10) Segnalazione terminazione nodo ed utente a master:
    si invia un sigchld al master (attenzione a sganciare l'handler prima della wait a fine simulazione): 
        utente aggiornato, manca il resto
11) Aggiornare inizializzazione random in nodo (con clock_gettime ?): OK
12) Sostituire atoi/atol con strtoi/strtol: nodo e utente ok

4) Aggiornare file di intestazione: Ok
5) Sistemazione e Test Nodo:
    -implementare parte aggiuntiva versione FULL
        -controllo periodico transazioni su coda globale: Ok
    -aggiungere var d'ambiente SO_HOPS: Ok
    -togliere lettura file: si fa solo nel master; nei figli
    si leggono solo le var d'ambiente: Ok
    -il codice del nodo va sistemato in modo che sia rientrante
    perchè potrebbe essere interrotto dal segnale della scandenza
    del timer per inviare la transazione all'invio. OK
    Ci sarebbe anche la possibilità di non usare un segnale
    ed inviare una transazione ad ogni iterazione del ciclo di vita del nodo
    (così però non si fanno un po' troppi invii? E soprattutto, non si perde
    la possibilità di regolare la velocità??)
    No, lasciamo il timer
6) Collegarsi alla lista dei nodi in sola lettura: utente e nodo OK
7) Fissare con precisione il numero di partizioni (per me va bene vincolarlo a 3): sono per forza 3
8) Verificare stato utente e nodo in inivio transazione: OK
8.2) Verificare stato nodo amico quando gli mandi la transazioni: OK [viene fatto in funzione extractFriendNode]
9) Spostare TEST_ERROR_PARAM in info.h e correggerla (cosa bisogna cambiare ?)
10) Definire una procedura che deallochi le facilities in caso di errore: OK
    -modificare la procedura di deallocazione corrente in modo che sappia
    gestire senza errori il caso in cui un oggetto IPC non esiste: Ok (solo per nodo e utente(?))
    -agganciare la procedure con atexit in modo che venga sempre eseguita alla terminazione
    (o richiamarla in caso di errore: questa è la soluzione scelta, l'altra è inutile): OK
    -agganciarla anche in caso di terminazione anomala
11) COntrollare i collegamenti in sola lettura ai segmenti: nodo ok
12) COmpilare tutto (check parentesi calcolo bilancio)
13) Implementare parte full master: OK
14) Inserire, nel nodo, l'aggiunta dell'amico su richiesta del master: Ok
15) Aggiornare il progetto alla luce del fatto che i nodi possano terminare
17) Segnalazione fallimento transazione a sender: controllo in utente già fatto, invio da parte di nodo OK
18) Per il master e i segmenti di shared memory abbiamo usato la soluzione fair di Gunetti
19) Aggiungere sincronizzazione in calcolo bilancio: Ok
20) sistemare costante dimensione file
21) Rilevazione invio a nodi terminati: OK, in fase di invio viene scelto un nodo attivo
22) Eliminare facilities inutili da node (usersList, rdPartSem, mutexPartSem, noReadersPartition, noUserSegReaders, userListSem): OK
23) Aggiornare lettura da file con versione seguente
    /*
    Versione ottimizzata lettura da file
    int readConfigParameters()
{
    char *filename = "params.txt";
    FILE *fp = fopen(filename, "r");
    /* Reading line by line, max 128 bytes*/
    /*
        SPOSTATO IN INFO.h
    */
    /*const unsigned MAX_LENGTH = 128;*/
    /* Array that will contain the lines read from the file
    // each "row" of the "matrix" will contain a different file line*/
    char line[CONF_MAX_LINE_NO][CONF_MAX_LINE_SIZE];
    /* Counter of the number of lines in the file*/
    int k = 0;
    char *aus = NULL;
    int exitCode = 0;
    int i = 0;

    printf("Node: reading configuration parameters...\n");

    aus = (char *)calloc(35, sizeof(char));
    if (aus == NULL)
        unsafeErrorPrint("Node: failed to allocate memory. Error: ");
    else
    {
        /* Handles any error in opening the file*/
        if (fp == NULL)
        {
            sprintf(aus, "Error: could not open file %s", filename);
            unsafeErrorPrint(aus);
            exitCode = EXIT_FAILURE;
        }
        else
        {
            /* Inserts the lines read from the file into the array*/
            /* It also inserts the parameters read into environment variables*/
            /*
            CORREGGERE: segnalare errori fgets
        */
            while (fgets(line[k], CONF_MAX_LINE_SIZE, fp) != NULL)
            {
                putenv(line[i]);
                k++;
            }

            if (line[k] == NULL)
            {
                unsafeErrorPrint("Node: failed to read cofiguration parameters. Error: ");
                exitCode = EXIT_FAILURE;
            }
            else
            {
                /* Assigns the values ​​of the environment
        // variables to the global variables defined above*/
                assignEnvironmentVariables();
            }

            /* Close the file*/
            fclose(fp);
        }
    }

    return exitCode;
}
*/
24) Modificare nodo per fare in modo che solo i nodi normali attendano l'inizio della simulazione: [non più da fare]
25) CONTROLLARE LO STATO DELL'UTENTE E DEL NODO A CUI SI INVIA UNA TRANSAZIONE: OK
    in utente ok (viene fatto in funzione di estrazione nodo e utente dest.), in nodo ok (viene fatto in funzione extractFriendNode)
26) Inviare notifica fallimento transazione a sender: controllo in utente già fatto, invio da parte di nodo OK
27) Verificare il bilancio prima di generare transazione in risposta a sigusr2: OK
28) Aggiungere lettura variabili globali nell'utente: OK
29) Sostituire write con printf (dove serve): utente ok, nodo ok, manca master
30) Handler CTRL + C master
31) Occorre rimuovere eventuali handler quando si esegue la procedura di terminazione??
32) DOBBIAMO STUDIARE SISTEMA DI AGGIONAMENTO STATO DEI NODI AMICI PER I NODI (AL MOMENTO NON POSSIAMO SAPERE SE UN NODO AMICO È TERMINATO O MENO!!!!)
    [abbiamo risolto stabilendo un massimo di nodi aggiuntivi che possono essere generati nella simulazione]: OK
33) Cosa facciamo in caso fallisca l'invio del messaggio che informa il sender che una sua transazione non è stata processata dal nodo?
34) Controllare i sizeof di tutte le msgsnd e msgrcv (non bisogna sottrarre la size del campo mType?): nodo OK
35) Sistemato ricezione amici da coda globale in nodo OK 
36) Verificare &sops[0]: funziona (OK)
37) In User dopo mandare sigchld al master, devo terminare? [DIPENDE DA COME IMPLEMENTIAMO HANDLER SIGCHLD]: OK (per ora termino)
38) Quando mandiamo in pause il nodo (in attesa che il padre gli dica di terminare), dovrei staccare anche l'handler dell'invio di 
    transazione ad amico ogni tot tempo? [FATTO]
39) Bisogna fare Handler SIGCHLD in master per gestire la terminazione prematura di nodi e utenti!!!
40) Controllare se funzione removeTransaction in User funziona correttamente

1) Parte full master: OK
2) SIstemare terminazione nodi (sincronizzazione accesso lista): IO
    -risolvere problema dimensione lista: Putroppo si risolve solo non redimensionando
    -controllare se si acceda alla lista nodi in modo sincronizzato
3) Aggiornare e testare il master integrando tutto: IO
4) Testare e uniformare il nodo
6) Testare e uniformare l'utente
7) Scrivere Relazione: Urru
9) Implementare modifiche scritte su file: Fontana
10) Cerchi problemi da risolvere: Fontana

Printf vs write:
    In tutte le funzioni che possono essere interrotti da un segnale per poi ripartire
    (gli handler, ma non solo) bisogna usare write

Tutto ciò entro il 12/01/2022

PUNTI ANCORA DA FARE:
5) -master per registrare terminazione nodi ed utenti
6) Sostituire sleep con nanosleep: utente e nodo ok
8) Testare meccanismo deallocazioni IPC in caso di errore su master
9) Terminazione in caso di errore fork nel master
10) Segnalazione terminazione nodo ed utente a master:
    si invia un sigchld al master (attenzione a sganciare l'handler prima della wait a fine simulazione): 
        utente aggiornato, manca il resto
9) Spostare TEST_ERROR_PARAM in info.h e correggerla (cosa bisogna cambiare ?)
11) COntrollare i collegamenti in sola lettura ai segmenti: nodo ok
12) COmpilare tutto (check parentesi calcolo bilancio)
15) Aggiornare il progetto alla luce del fatto che i nodi possano terminare
20) sistemare costante dimensione file
29) Sostituire write con printf (dove serve): utente ok, nodo ok, manca master
30) Handler CTRL + C master
31) Occorre rimuovere eventuali handler quando si esegue la procedura di terminazione??
33) Cosa facciamo in caso fallisca l'invio del messaggio che informa il sender che una sua transazione non è stata processata dal nodo?
39) Bisogna fare Handler SIGCHLD in master per gestire la terminazione prematura di nodi e utenti!!!
40) Controllare se funzione removeTransaction in User funziona correttamente

Conteggio nodi ed utenti attivi (copiato qui per emergenze, per ora non serve)
/*
                                    c_users_active = 0;
                                    c_nodes_active = 0;

                                    /* we enter the critical section for the noUserSegReadersPtr variabile */
                                    sops[0].sem_num = 0;
                                    sops[0].sem_op = -1;
                                    if (semop(userListSem, &sops[0], 1) == -1)
                                    {
                                        safeErrorPrint("Master: failed to reserve mutex usersList semaphore. Error: ");
                                    }
                                    else
                                    {
                                        (*noUserSegReadersPtr)++;
                                        if ((*noUserSegReadersPtr) == 1)
                                        {
                                            sops[0].sem_num = 2;
                                            sops[0].sem_op = -1; /* controllare se giusto!!! */
                                            if (semop(userListSem, &sops[0], 1) == -1)
                                            {
                                                safeErrorPrint("Master: failed to reserve write usersList semaphore. Error: ");
                                            }
                                            /* 
                                        * se lo scrittore sta scrivendo, allora il primo lettore che entrerà in questo 
                                        * ramo si addormenterà su questo semaforo.
                                        * se lo scrittore non sta scrivendo, allora il primo lettore decrementerà di 1 il
                                        * valore semaforico, in modo tale se lo scrittore vuole scrivere, si addormenterà 
                                        * sul semaforo
                                        */
                                        }
                                        /* we exit the critical section for the noUserSegReadersPtr variabile */
                                        sops[0].sem_num = 0;
                                        sops[0].sem_op = 1;
                                        if (semop(userListSem, &sops[0], 1) == -1)
                                        {
                                            safeErrorPrint("Master: failed to release mutex usersList semaphore. Error: ");
                                        }
                                        else
                                        {
                                            /* initializing budget for users processes */
                                            for (i = 0; i < SO_USERS_NUM; i++)
                                            {
                                                if (usersList[i].procState == ACTIVE)
                                                    c_users_active++;
                                            }

                                            /* we enter the critical section for the noUserSegReadersPtr variabile */
                                            sops[0].sem_num = 0;
                                            sops[0].sem_op = -1;
                                            if (semop(userListSem, &sops[0], 1) == -1)
                                            {
                                                safeErrorPrint("Master: failed to reserve mutex usersList semaphore. Error: ");
                                            }
                                            else
                                            {
                                                (*noUserSegReadersPtr)--;
                                                if ((*noUserSegReadersPtr) == 0)
                                                {
                                                    sops[0].sem_num = 2;
                                                    sops[0].sem_op = 1; /* controllare se giusto!!! */
                                                    if (semop(userListSem, &sops[0], 1) == -1)
                                                    {
                                                        safeErrorPrint("Master: failed to reserve write usersList semaphore. Error: ");
                                                    }
                                                    /* 
                                                * se sono l'ultimo lettore e smetto di leggere, allora devo riportare a 0
                                                * il valore semaforico in modo che se lo scrittore vuole scrivere possa farlo.
                                                */
                                                }
                                                /* we exit the critical section for the noUserSegReadersPtr variabile */
                                                sops[0].sem_num = 0;
                                                sops[0].sem_op = 1;
                                                if (semop(userListSem, &sops[0], 1) == -1)
                                                {
                                                    safeErrorPrint("Master: failed to release mutex usersList semaphore. Error: ");
                                                }
                                                else
                                                {
                                                    /* checking if there are active user processes, if not, simulation must terminate */
                                                    printf("Master: checking if there are active user processes...\n");
                                                    if (!c_users_active)
                                                    {
                                                        /* it contains an exit call
                                                    so no need to set exit code*/
                                                        printf("Master: no more active user processes. Terminating simulation...\n");
                                                        endOfSimulation(SIGUSR1);
                                                        /* CHECK IF ITS CORRECT ??? */
                                                    }
                                                    printf("Master: there are %d active user processes, continuing...\n", c_users_active);
                                                }
                                            }
                                        }
                                    }

                                    /* we enter the critical section for the noNodeSegReadersPtr variabile */
                                    sops[0].sem_num = 0;
                                    sops[0].sem_op = -1;
                                    if (semop(nodeListSem, &sops[0], 1) == -1)
                                    {
                                        safeErrorPrint("Master: failed to reserve mutex nodeList semaphore. Error: ");
                                    }
                                    else
                                    {
                                        (*noNodeSegReadersPtr)++;
                                        if ((*noNodeSegReadersPtr) == 1)
                                        {
                                            sops[0].sem_num = 2;
                                            sops[0].sem_op = -1; /* controllare se giusto!!! */
                                            if (semop(nodeListSem, &sops[0], 1) == -1)
                                            {
                                                safeErrorPrint("Master: failed to reserve write nodeList semaphore. Error: ");
                                            }
                                            /* 
                                            * se lo scrittore sta scrivendo, allora il primo lettore che entrerà in questo 
                                            * ramo si addormenterà su questo semaforo.
                                            * se lo scrittore non sta scrivendo, allora il primo lettore decrementerà di 1 il
                                            * valore semaforico, in modo tale se lo scrittore vuole scrivere, si addormenterà 
                                            * sul semaforo
                                            */
                                        }
                                        /* we exit the critical section for the noNodeSegReadersPtr variabile */
                                        sops[0].sem_num = 0;
                                        sops[0].sem_op = 1;
                                        if (semop(nodeListSem, &sops[0], 1) == -1)
                                        {
                                            safeErrorPrint("Master: failed to release mutex nodeList semaphore. Error: ");
                                        }
                                        else
                                        {
                                            /* initializing budget for nodes processes */
                                            for (i = 0; i < SO_NODES_NUM; i++)
                                            {
                                                if (nodesList[i].procState == ACTIVE)
                                                    c_nodes_active++;
                                            }

                                            /* we enter the critical section for the noNodeSegReadersPtr variabile */
                                            sops[0].sem_num = 0;
                                            sops[0].sem_op = -1;
                                            if (semop(nodeListSem, &sops[0], 1) == -1)
                                            {
                                                safeErrorPrint("Master: failed to reserve mutex nodeList semaphore. Error: ");
                                            }
                                            else
                                            {
                                                (*noNodeSegReadersPtr)--;
                                                if ((*noNodeSegReadersPtr) == 0)
                                                {
                                                    sops[0].sem_num = 2;
                                                    sops[0].sem_op = 1; /* controllare se giusto!!! */
                                                    if (semop(nodeListSem, &sops[0], 1) == -1)
                                                    {
                                                        safeErrorPrint("Master: failed to reserve write nodeList semaphore. Error: ");
                                                    }
                                                    /* 
                                                * se sono l'ultimo lettore e smetto di leggere, allora devo riportare a 0
                                                * il valore semaforico in modo che se lo scrittore vuole scrivere possa farlo.
                                                */
                                                }
                                                /* we exit the critical section for the noNodeSegReadersPtr variabile */
                                                sops[0].sem_num = 0;
                                                sops[0].sem_op = 1;
                                                if (semop(nodeListSem, &sops[0], 1) == -1)
                                                    safeErrorPrint("Master: failed to release mutex nodeList semaphore. Error: ");
                                                else
                                                    printf("Master: there are %d active node processes\n", c_nodes_active);
                                            }
                                        }
                                    }